<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Embedder &mdash; Music Embedding 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="_static/css/style.css" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />

  
    <link rel="shortcut icon" href="_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=fc837d61"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #222" >

          
          
          <a href="index.html">
            
              <img src="_static/music_embedding.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Embedder</a><ul>
<li><a class="reference internal" href="#music_embedding.embedder.embedder"><code class="docutils literal notranslate"><span class="pre">embedder</span></code></a><ul>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.chunk_sequence_of_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.chunk_sequence_of_intervals()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll"><code class="docutils literal notranslate"><span class="pre">embedder.extract_highest_pitch_notes_from_pianoroll()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_RLE_from_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.get_RLE_from_intervals()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_RLE_from_intervals_bulk"><code class="docutils literal notranslate"><span class="pre">embedder.get_RLE_from_intervals_bulk()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll"><code class="docutils literal notranslate"><span class="pre">embedder.get_barwise_intervals_from_pianoroll()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll"><code class="docutils literal notranslate"><span class="pre">embedder.get_harmonic_intervals_from_pianoroll()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_intervals_from_RLE"><code class="docutils literal notranslate"><span class="pre">embedder.get_intervals_from_RLE()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_intervals_from_RLE_bulk"><code class="docutils literal notranslate"><span class="pre">embedder.get_intervals_from_RLE_bulk()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll"><code class="docutils literal notranslate"><span class="pre">embedder.get_melodic_intervals_from_pianoroll()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.get_pianoroll_from_barwise_intervals()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.get_pianoroll_from_harmonic_intervals()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.get_pianoroll_from_melodic_intervals()</span></code></a></li>
<li><a class="reference internal" href="#music_embedding.embedder.embedder.merge_chunked_intervals"><code class="docutils literal notranslate"><span class="pre">embedder.merge_chunked_intervals()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #222" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Music Embedding</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Embedder</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/embedder.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-music_embedding.embedder">
<span id="embedder"></span><h1>Embedder<a class="headerlink" href="#module-music_embedding.embedder" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">music_embedding.embedder.</span></span><span class="sig-name descname"><span class="pre">embedder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pianoroll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_velocity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixels_per_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">96</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for embedding musical data, providing functionalities to convert between pianoroll representations
and interval-based representations.</p>
<p>This class handles various operations related to musical data manipulation, including extracting notes from
pianorolls, converting pianoroll data to melodic, harmonic, and barwise intervals, and vice versa. Additionally,
it supports Run-Length Encoding (RLE) compression for intervals.</p>
<p>The constant <cite>NOTES_IN_MIDI</cite> is set to 128, reflecting the total number of MIDI notes in the standard MIDI range.
This constant is used throughout the class to standardize the size of the second dimension in pianoroll arrays,
ensuring they conform to MIDI standards. The pianoroll arrays are therefore structured with a shape of (?, 128),
where each column represents a possible MIDI note, allowing for a consistent representation of musical data.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">interval</span></code></dt><dd><p>Class used for interval-related calculations.</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128), optional</span></dt><dd><p>Pianoroll representation of musical data. The first dimension represents timesteps, and the second dimension
has a fixed size of 128, corresponding to MIDI standards.</p>
</dd>
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span></dt><dd><p>Interval representation of musical data. The first dimension represents timesteps, and the second dimension
corresponds to interval features.</p>
</dd>
<dt><strong>default_velocity</strong><span class="classifier">int</span></dt><dd><p>Default velocity used for notes in pianoroll representation. Defaults to 100.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">int</span></dt><dd><p>Reference note for melody, used as the starting note when decoding a melody. Defaults to 60 (Middle C in MIDI)</p>
</dd>
<dt><strong>pixels_per_bar</strong><span class="classifier">int</span></dt><dd><p>Number of pixels representing each bar in a pianoroll, calculated as the time signature’s numerator multiplied
by the resolution per pixel. Defaults to 96.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.chunk_sequence_of_intervals" title="music_embedding.embedder.embedder.chunk_sequence_of_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chunk_sequence_of_intervals</span></code></a>([intervals, ...])</p></td>
<td><p>Breaks a long sequence of intervals into chunks of a specified length.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll" title="music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_highest_pitch_notes_from_pianoroll</span></code></a>([...])</p></td>
<td><p>Extracts the highest pitch note at each timestep from the pianoroll attribute.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_RLE_from_intervals" title="music_embedding.embedder.embedder.get_RLE_from_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_RLE_from_intervals</span></code></a>([intervals])</p></td>
<td><p>Compresses a sequence of intervals using Run-Length Encoding (RLE).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_RLE_from_intervals_bulk" title="music_embedding.embedder.embedder.get_RLE_from_intervals_bulk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_RLE_from_intervals_bulk</span></code></a>(bulk_intervals)</p></td>
<td><p>Bulk compresses a sequence of intervals using Run-Length Encoding (RLE).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll" title="music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_barwise_intervals_from_pianoroll</span></code></a>([...])</p></td>
<td><p>Creates a sequence of barwise intervals from a pianoroll, calculating intervals with respect to the first note of each bar.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll" title="music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_harmonic_intervals_from_pianoroll</span></code></a>(...[, ...])</p></td>
<td><p>Creates a sequence of harmonic intervals from the pianoroll relative to a reference pianoroll.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_intervals_from_RLE" title="music_embedding.embedder.embedder.get_intervals_from_RLE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_intervals_from_RLE</span></code></a>(RLE_data)</p></td>
<td><p>Uncompresses a Run-Length Encoded sequence of intervals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_intervals_from_RLE_bulk" title="music_embedding.embedder.embedder.get_intervals_from_RLE_bulk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_intervals_from_RLE_bulk</span></code></a>(bulk_RLE_data)</p></td>
<td><p>Bulk uncompresses a sequence of Run-Length Encoded intervals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll" title="music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_melodic_intervals_from_pianoroll</span></code></a>([pianoroll])</p></td>
<td><p>Creates a sequence of melodic intervals from a pianoroll.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals" title="music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pianoroll_from_barwise_intervals</span></code></a>([...])</p></td>
<td><p>Creates a pianoroll from a sequence of barwise intervals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals" title="music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pianoroll_from_harmonic_intervals</span></code></a>([...])</p></td>
<td><p>Creates a pianoroll from a sequence of harmonic intervals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals" title="music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pianoroll_from_melodic_intervals</span></code></a>([...])</p></td>
<td><p>Creates a pianoroll from a sequence of melodic intervals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#music_embedding.embedder.embedder.merge_chunked_intervals" title="music_embedding.embedder.embedder.merge_chunked_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_chunked_intervals</span></code></a>(chunked_intervals)</p></td>
<td><p>Merges chunks of interval sequences into a single sequence.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.chunk_sequence_of_intervals">
<span class="sig-name descname"><span class="pre">chunk_sequence_of_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixels_per_chunk</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.chunk_sequence_of_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.chunk_sequence_of_intervals" title="Link to this definition"></a></dt>
<dd><p>Breaks a long sequence of intervals into chunks of a specified length.</p>
<p>This method divides a sequence of intervals into smaller, equally-sized chunks, which can be useful for
processing or analyzing data in segments. If <cite>intervals</cite> is None, the method works on <cite>self.intervals</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span></dt><dd><p>Sequence of intervals to be chunked. If None, uses <cite>self.intervals</cite>.</p>
</dd>
<dt><strong>pixels_per_chunk</strong><span class="classifier">int</span></dt><dd><p>Number of pixels in each chunk. Defaults to <cite>self.pixels_per_bar</cite> if None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int8</dt><dd><p>Array of chunked intervals. Shape is (?, pixels_per_chunk, interval.feature_dimensions),
where ? is the number of chunks.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both <cite>intervals</cite> argument and <cite>self.intervals</cite> are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If <cite>intervals</cite> shape’s second dimension is not equal to <cite>interval.feature_dimensions</cite>.</p>
</dd>
<dt>ValueError</dt><dd><p>If <cite>pixels_per_chunk</cite> is less than 1 or if it’s None and <cite>self.pixels_per_bar</cite> is less than 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll">
<span class="sig-name descname"><span class="pre">extract_highest_pitch_notes_from_pianoroll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preserve_pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.extract_highest_pitch_notes_from_pianoroll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll" title="Link to this definition"></a></dt>
<dd><p>Extracts the highest pitch note at each timestep from the pianoroll attribute.</p>
<p>This method processes the <cite>self.pianoroll</cite> array to find the highest pitch note for each timestep.
It can operate in either a non-destructive mode, preserving the original pianoroll, or a faster,
destructive mode that alters the original data.</p>
<p><strong>Example:</strong> Given the pianoroll of an SATB choir, returns Soprano notes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>preserve_pianoroll</strong><span class="classifier">bool, optional</span></dt><dd><p>Determines if <cite>self.pianoroll</cite> should be preserved.
Setting it to False increases performance by avoiding data copying. Default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int64, shape=(?)</dt><dd><p>An array containing the highest pitch note at each timestep. Indicates silence with a value of 0.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If <cite>self.pianoroll</cite> is None.</p>
</dd>
<dt>IndexError</dt><dd><p>If <cite>self.pianoroll</cite> does not have the second dimension size of 128.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method operates on <cite>self.pianoroll</cite> and requires it to be filled before calling.
The pianoroll format is expected to conform to MIDI standards with 128 pitches.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_RLE_from_intervals">
<span class="sig-name descname"><span class="pre">get_RLE_from_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_RLE_from_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_RLE_from_intervals" title="Link to this definition"></a></dt>
<dd><p>Compresses a sequence of intervals using Run-Length Encoding (RLE).</p>
<p>This method takes a sequence of intervals and compresses it using RLE, which is useful
for reducing the size of repetitive data. The output is an array where each row represents
a compressed sequence of intervals, and the last column in each row indicates the number
of repetitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions) | None, optional</span></dt><dd><p>The sequence of intervals to be compressed. If None, uses self.intervals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int32, shape=(?, interval.feature_dimensions + 1)</dt><dd><p>The RLE compressed intervals. Each row contains the compressed interval data with
the last element indicating the count of repetitions.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both intervals argument and self.intervals are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If intervals.shape[1] != interval.feature_dimensions (if intervals is None,
then self.intervals.shape[1] is checked).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_RLE_from_intervals_bulk">
<span class="sig-name descname"><span class="pre">get_RLE_from_intervals_bulk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bulk_intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_RLE_from_intervals_bulk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_RLE_from_intervals_bulk" title="Link to this definition"></a></dt>
<dd><p>Bulk compresses a sequence of intervals using Run-Length Encoding (RLE).</p>
<p>This method processes multiple sequences of intervals simultaneously, applying RLE compression to each
sequence in the bulk data. It is useful for handling large datasets where individual processing would be
inefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bulk_intervals</strong><span class="classifier">ndarray</span></dt><dd><p>An array containing multiple sequences of intervals, with shape (n_chunks, chunk_size,
interval.feature_dimensions). Each sequence (chunk) in the first dimension will be compressed using RLE.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>List[ndarray]</dt><dd><p>A list of RLE-compressed interval sequences, where each element in the list corresponds to the RLE
representation of a chunk in <cite>bulk_intervals</cite>. Each ndarray in the list has shape (?,
interval.feature_dimensions + 1), where the last dimension includes the run lengths.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#music_embedding.embedder.embedder.get_RLE_from_intervals" title="music_embedding.embedder.embedder.get_RLE_from_intervals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_RLE_from_intervals</span></code></a></dt><dd><p>Compresses a single sequence of intervals using Run-Length Encoding.</p>
</dd>
<dt><a class="reference internal" href="#music_embedding.embedder.embedder.get_intervals_from_RLE_bulk" title="music_embedding.embedder.embedder.get_intervals_from_RLE_bulk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_intervals_from_RLE_bulk</span></code></a></dt><dd><p>Bulk decompresses Run-Length Encoded interval sequences.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll">
<span class="sig-name descname"><span class="pre">get_barwise_intervals_from_pianoroll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixels_per_bar</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_barwise_intervals_from_pianoroll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll" title="Link to this definition"></a></dt>
<dd><p>Creates a sequence of barwise intervals from a pianoroll, calculating intervals with respect to the first note
of each bar. For the first notes of bars, intervals are calculated with respect to the first note of the
previous bar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128) | None, optional</span></dt><dd><p>Pianoroll representation of musical data. If not provided, <cite>self.pianoroll</cite> is used. The first dimension
represents timesteps, and the second dimension has a fixed size of 128, corresponding to MIDI standards.</p>
</dd>
<dt><strong>pixels_per_bar</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of pixels in each bar, equal to the time signature’s numerator multiplied by the resolution per
pixel. If not provided, <cite>self.pixels_per_bar</cite> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</dt><dd><p>Interval representation of musical data. The first dimension represents timesteps, and the second dimension
corresponds to interval features.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both <cite>pianoroll</cite> argument and <cite>self.pianoroll</cite> are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If <cite>pianoroll.shape[1]</cite> != 128.</p>
</dd>
<dt>ValueError</dt><dd><p>If <cite>pixels_per_bar</cite> &lt; 1 or if <cite>pixels_per_bar</cite> is None and <cite>self.pixels_per_bar</cite> &lt; 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll">
<span class="sig-name descname"><span class="pre">get_harmonic_intervals_from_pianoroll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_harmonic_intervals_from_pianoroll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll" title="Link to this definition"></a></dt>
<dd><p>Creates a sequence of harmonic intervals from the pianoroll relative to a reference pianoroll.</p>
<p>This method computes harmonic intervals of the highest pitch notes in <cite>self.pianoroll</cite> with
respect to <cite>ref_pianoroll</cite>. It updates <cite>self.pianoroll</cite> if <cite>pianoroll</cite> argument is passed
and also updates <cite>self.intervals</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ref_pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128)</span></dt><dd><p>Reference pianoroll to which harmonic intervals are calculated.</p>
</dd>
<dt><strong>pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128) | None, default=None</span></dt><dd><p>Pianoroll for which to calculate harmonic intervals. If None, uses <cite>self.pianoroll</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</dt><dd><p>Array of harmonic intervals. First dimension represents timesteps, and the second
dimension corresponds to interval features.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both <cite>pianoroll</cite> argument and <cite>self.pianoroll</cite> are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If <cite>pianoroll.shape[1]</cite> is not 128 or if <cite>ref_pianoroll.shape[1]</cite> is not 128.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_intervals_from_RLE">
<span class="sig-name descname"><span class="pre">get_intervals_from_RLE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">RLE_data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_intervals_from_RLE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_intervals_from_RLE" title="Link to this definition"></a></dt>
<dd><p>Uncompresses a Run-Length Encoded sequence of intervals.</p>
<p>This method takes a Run-Length Encoded (RLE) array representing a sequence of intervals and
decompresses it to obtain the original sequence of intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>RLE_data</strong><span class="classifier">ndarray, dtype=int32, shape=(?, interval.feature_dimensions + 1)</span></dt><dd><p>Compressed intervals using Run-Length Encoding. The last element in each row indicates
the number of repetitions for the interval.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</dt><dd><p>Decompressed sequence of intervals. The first dimension represents timesteps, and the
second dimension corresponds to interval features.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_intervals_from_RLE_bulk">
<span class="sig-name descname"><span class="pre">get_intervals_from_RLE_bulk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bulk_RLE_data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_intervals_from_RLE_bulk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_intervals_from_RLE_bulk" title="Link to this definition"></a></dt>
<dd><p>Bulk uncompresses a sequence of Run-Length Encoded intervals.</p>
<p>This method uncompresses multiple sequences of intervals that have been compressed using
Run-Length Encoding (RLE). It processes a list of RLE-compressed data and returns the
uncompressed intervals in bulk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bulk_RLE_data</strong><span class="classifier">List[np.ndarray]</span></dt><dd><p>A list of RLE-compressed data, where each element is an ndarray with the shape
(?, interval.feature_dimensions + 1). The last element in each row indicates the number
of repetitions for the rest of the elements in the row.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>np.ndarray</dt><dd><p>An ndarray of uncompressed intervals. The shape of the output array is
(?, pixels_per_chunk, interval.feature_dimensions), where the first dimension represents
chunks, the second dimension represents pixels in each chunk, and the third dimension
represents interval features.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The output size is inferred from the first chunk in the bulk RLE data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll">
<span class="sig-name descname"><span class="pre">get_melodic_intervals_from_pianoroll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_melodic_intervals_from_pianoroll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll" title="Link to this definition"></a></dt>
<dd><p>Creates a sequence of melodic intervals from a pianoroll.</p>
<p>This method calculates the melodic intervals of the highest pitch notes in the pianoroll.
If a pianoroll is provided as an argument, it updates <cite>self.pianoroll</cite> with this new data.
The resulting intervals are stored in <cite>self.intervals</cite>.</p>
<p><strong>Example:</strong> Given the pianoroll of an SATB choir, returns melodic intervals of Soprano.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128), optional</span></dt><dd><p>Pianoroll to be processed. If not provided, the method uses <cite>self.pianoroll</cite>. The first dimension represents
timesteps, and the second dimension is fixed to 128, corresponding to MIDI standards.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</dt><dd><p>Array of melodic intervals. The first dimension represents timesteps, and the second dimension corresponds
to interval features.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both the pianoroll argument and <cite>self.pianoroll</cite> are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If the provided pianoroll (or <cite>self.pianoroll</cite> if pianoroll is None) does not have a second dimension of
size 128.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals">
<span class="sig-name descname"><span class="pre">get_pianoroll_from_barwise_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leading_silence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixels_per_bar</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_pianoroll_from_barwise_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals" title="Link to this definition"></a></dt>
<dd><p>Creates a pianoroll from a sequence of barwise intervals.</p>
<p>This method decodes barwise interval data into a pianoroll representation, considering each bar’s
first note and the intervals following it. It supports specifying the origin note, velocity, leading
silence, and pixels per bar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions), default=None</span></dt><dd><p>Sequence of barwise intervals. Uses <cite>self.intervals</cite> if None.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">int, default=None</span></dt><dd><p>Reference note for the melody (MIDI value). Uses <cite>self.origin</cite> if None.</p>
</dd>
<dt><strong>velocity</strong><span class="classifier">int, default=None</span></dt><dd><p>Velocity for notes in the pianoroll. Uses <cite>self.default_velocity</cite> if None.</p>
</dd>
<dt><strong>leading_silence</strong><span class="classifier">int, default=0</span></dt><dd><p>Number of silent pixels at the beginning of the melody.</p>
</dd>
<dt><strong>pixels_per_bar</strong><span class="classifier">int, default=None</span></dt><dd><p>Number of pixels in each bar. Uses <cite>self.pixels_per_bar</cite> if None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=uint8, shape=(?, 128)</dt><dd><p>Pianoroll representation with each timestep and MIDI note.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>pixels_per_bar</cite> is less than 1 or <cite>leading_silence</cite> is greater than or equal to the
length of intervals.</p>
</dd>
<dt>IndexError</dt><dd><p>If <cite>origin</cite> or <cite>velocity</cite> is out of MIDI range (0-127), or if note calculations lead to
values outside this range.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals">
<span class="sig-name descname"><span class="pre">get_pianoroll_from_harmonic_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pianoroll</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_pianoroll_from_harmonic_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals" title="Link to this definition"></a></dt>
<dd><p>Creates a pianoroll from a sequence of harmonic intervals.</p>
<p>This method builds a new pianoroll based on the highest pitch notes extracted from the provided or
class’s pianoroll and the harmonic intervals stored in the class’s intervals.</p>
<p><strong>Example:</strong> Given ATB choir pianoroll and Soprano’s harmonic intervals with respect to Alto,
returns Soprano’s pianoroll.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pianoroll</strong><span class="classifier">ndarray, dtype=uint8, shape=(?, 128) | None, optional</span></dt><dd><p>Pianoroll representation of musical data to be used. If None, the method uses self.pianoroll.</p>
</dd>
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions) | None, optional</span></dt><dd><p>Sequence of harmonic intervals. If None, the method uses self.intervals.</p>
</dd>
<dt><strong>velocity</strong><span class="classifier">int | None, optional</span></dt><dd><p>Velocity for notes in the pianoroll. If None, self.default_velocity is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=uint8, shape=(?, 128)</dt><dd><p>The generated pianoroll, where the first dimension is timesteps and the second dimension
is fixed to 128 per MIDI standard.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both pianoroll argument and self.pianoroll are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If pianoroll.shape[1] != 128, or if intervals.shape[1] != interval.feature_dimensions,
or if adding the interval to the pianoroll leads to a note out of MIDI range (0-127),
or if velocity is out of MIDI range (0-127).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals">
<span class="sig-name descname"><span class="pre">get_pianoroll_from_melodic_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leading_silence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.get_pianoroll_from_melodic_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals" title="Link to this definition"></a></dt>
<dd><p>Creates a pianoroll from a sequence of melodic intervals.</p>
<p>This method generates a pianoroll representation of a melody based on the provided sequence of melodic
intervals. The origin note is used as the starting point for the melody, and the specified velocity is
applied to the notes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intervals</strong><span class="classifier">ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span></dt><dd><p>Sequence of melodic intervals. If None, the method uses self.intervals.
Each row represents interval features for a timestep.</p>
</dd>
<dt><strong>origin</strong><span class="classifier">int, optional</span></dt><dd><p>The reference note of the melody; used as the starting note for decoding the melody.
Defaults to self.origin if None.</p>
</dd>
<dt><strong>velocity</strong><span class="classifier">int, optional</span></dt><dd><p>Velocity used for notes in the pianoroll. Defaults to self.default_velocity if None.</p>
</dd>
<dt><strong>leading_silence</strong><span class="classifier">int, optional</span></dt><dd><p>Number of silent pixels at the beginning of the melody. Defaults to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dtype=uint8, shape=(?, 128)</dt><dd><p>Pianoroll representation of the melody. The first dimension represents timesteps, and the second dimension
is fixed to 128, corresponding to MIDI standards.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If both intervals argument and self.intervals are None.</p>
</dd>
<dt>IndexError</dt><dd><p>If intervals.shape[1] != interval.feature_dimensions or if the sequence of given intervals leads to a
note outside the MIDI range (0-127).</p>
</dd>
<dt>ValueError</dt><dd><p>If leading_silence is greater than or equal to the number of intervals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="music_embedding.embedder.embedder.merge_chunked_intervals">
<span class="sig-name descname"><span class="pre">merge_chunked_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunked_intervals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/music_embedding/embedder.html#embedder.merge_chunked_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#music_embedding.embedder.embedder.merge_chunked_intervals" title="Link to this definition"></a></dt>
<dd><p>Merges chunks of interval sequences into a single sequence.</p>
<p>This method flattens a 3D array of chunked intervals into a 2D array, where the first dimension represents
the total timesteps and the second dimension represents interval features. It is useful for reassembling
interval data that was previously divided into chunks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chunked_intervals</strong><span class="classifier">ndarray</span></dt><dd><p>A 3D array of chunked intervals, with shape (num_chunks, chunk_size, interval.feature_dimensions).
Each chunk represents a portion of the interval sequence.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>A 2D array of merged intervals, with shape (num_timesteps, interval.feature_dimensions). Represents the
entire sequence of intervals as a single continuous array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-24, SeyyedPooya HekmatiAthar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>