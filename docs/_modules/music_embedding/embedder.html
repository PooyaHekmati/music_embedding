
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>music_embedding.embedder &#8212; Music Embedding 0.1.7 alpha documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for music_embedding.embedder</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.interval</span> <span class="kn">import</span> <span class="n">interval</span>       
    
<div class="viewcode-block" id="embedder"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder">[docs]</a><span class="k">class</span> <span class="nc">embedder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; The embedding class for musical data. Provides functionallities to convert pianorolls into intervals and vice versa (embedding). </span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pianoroll : ndarray, dtype=uint8, shape=(?, 128), optional</span>
<span class="sd">        First dimension is timesteps and second dimension is fixed 128 per MIDI standard. The default is None.</span>
<span class="sd">            </span>
<span class="sd">    intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">        First dimension is timesteps and second dimension is interval features. The default is None.</span>
<span class="sd">            </span>
<span class="sd">    default_velocity : int</span>
<span class="sd">        When creating pianorolls this value is used for notes&#39; velocities. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">    origin : int</span>
<span class="sd">        The reference note of a melody; when decoding a melody, this indicates the first note. The default is 60.</span>
<span class="sd">            </span>
<span class="sd">    pixels_per_bar : int</span>
<span class="sd">        Number of pixels in each bar. Equals time signature&#39;s numarator multiplied by resolution per pixel. The default is 96.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pianoroll</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_velocity</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">pixels_per_bar</span><span class="o">=</span><span class="mi">96</span><span class="p">):</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">pianoroll</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_velocity</span><span class="o">=</span><span class="n">default_velocity</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">=</span><span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixels_per_bar</span><span class="o">=</span><span class="n">pixels_per_bar</span>
    
<div class="viewcode-block" id="embedder.extract_highest_pitch_notes_from_pianoroll"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.extract_highest_pitch_notes_from_pianoroll">[docs]</a>    <span class="k">def</span> <span class="nf">extract_highest_pitch_notes_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preserve_pianoroll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts highest pitch note at each timestep from pianoroll.</span>
<span class="sd">        </span>
<span class="sd">        **Example:** Given the pianoroll of an SATB choir, returns Soprano notes.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.pianoroll`, fill it before calling this function.  </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        preserve_pianoroll : boolean</span>
<span class="sd">            Determines if self.pianoroll needs to be preserved. Setting it to False slightly increases the performance.  </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array, dtype=int64, shape=(?)</span>
<span class="sd">            Contains the highest pitch note at each timestep. Indicates silence with 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preserve_pianoroll</span><span class="p">:</span>
            <span class="n">pianoroll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="p">)</span>   <span class="c1">#to make the process non-destructive and presereve the pianoroll</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pianoroll</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span>            <span class="c1">#to make the process faster but in a destructive manner</span>

        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pianoroll</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">pianoroll</span><span class="p">)</span>    <span class="c1">#clipping is applied to ensure coef works as expected.</span>
        
        <span class="n">coef</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">129</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>   <span class="c1">#128 is the number of notes in MIDI, arange&#39;s stop is exclusive so it has to be 129                               </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pianoroll</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pianoroll</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*=</span><span class="n">coef</span>                <span class="c1">#coef is a constantly growing series. Its multiplication is needed to ensure the note with the highest pitch is selected in a chord.</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pianoroll</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>        </div>
        
<div class="viewcode-block" id="embedder.get_melodic_intervals_from_pianoroll"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_melodic_intervals_from_pianoroll">[docs]</a>    <span class="k">def</span> <span class="nf">get_melodic_intervals_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pianoroll</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates sequence of melodic intervals from pianoroll.</span>
<span class="sd">        </span>
<span class="sd">        **Example:** Given the pianoroll of an SATB choir, returns melodic intervals of Soprano.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----        </span>
<span class="sd">        - Works on highest pitch notes in `self.pianoroll`</span>
<span class="sd">        - Updates `self.pianoroll` if pianoroll argument is passed.</span>
<span class="sd">        - Updates `self.intervals`.</span>
<span class="sd">     </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pianoroll : ndarray, dtype=uint8, shape=(?, 128), optional</span>
<span class="sd">            If None, the function expects self.pianoroll to have value; else, it overwrites self.pianoroll. First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span>
<span class="sd">            First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">pianoroll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">pianoroll</span>
        
        <span class="n">notes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_highest_pitch_notes_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1">#first get the notes of the melody</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">),</span><span class="n">interval</span><span class="o">.</span><span class="n">feature_dimensions</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="c1">#create the placeholder of intervals.</span>
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>
        <span class="n">last_voice_index</span><span class="o">=</span><span class="mi">0</span>
        
        <span class="n">silent_interval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">get_silence_specs_list</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>                         <span class="c1">#if the first pixel is silence there is no interval to calculate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span>   <span class="c1">#The first melodic interval is always zeros. This is becuase melody is calcualted with respect to the previous note.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>                     <span class="c1">#it is silence and there is no interval to calculate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span>   
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curser</span><span class="o">.</span><span class="n">semitones</span><span class="o">=</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">notes</span><span class="p">[</span><span class="n">last_voice_index</span><span class="p">]</span>
                <span class="n">curser</span><span class="o">.</span><span class="n">semitone2interval</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">curser</span><span class="o">.</span><span class="n">get_specs_list</span><span class="p">()</span>
                <span class="n">last_voice_index</span><span class="o">=</span><span class="n">i</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span>        </div>
<div class="viewcode-block" id="embedder.pianoroll2intervals_melody"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.pianoroll2intervals_melody">[docs]</a>    <span class="k">def</span> <span class="nf">pianoroll2intervals_melody</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is depricated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Call to function:</span>
<span class="sd">            :func:`get_melodic_intervals_from_pianoroll`</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_melodic_intervals_from_pianoroll</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="embedder.get_pianoroll_from_melodic_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_pianoroll_from_melodic_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_pianoroll_from_melodic_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leading_silence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates pianoroll from sequence of melodic intervals.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.intervals`</span>
<span class="sd">        - Updates `self.intervals` if intervals argument is passed.</span>
<span class="sd">        - Updates `self.pianoroll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">            If None, the function expects self.intervals to have value; else, it overwrites self.intervals. First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">            </span>
<span class="sd">        origin: int, optional</span>
<span class="sd">            The reference note of the melody; when decoding the melody, this indicates the first note. The default is self.origin.</span>
<span class="sd">            </span>
<span class="sd">        velocity : int, optional</span>
<span class="sd">           When creating pianorolls this value is used for notes&#39; velocities. The default is self.default_velocity.</span>
<span class="sd">           </span>
<span class="sd">        leading_silence: int, optional</span>
<span class="sd">            Number of silent pixels at the beginning of the melody.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=uint8, shape=(?, 128)</span>
<span class="sd">            First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
            
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
            
        <span class="k">if</span> <span class="n">velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">velocity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_velocity</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>         <span class="c1">#removing the first row of zeros. This is becuase melody is calcualted with respect to the previous note.</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">128</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>   <span class="c1">#128 is the number of notes in MIDI        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span> <span class="p">[</span> <span class="n">leading_silence</span><span class="p">,</span> <span class="n">origin</span> <span class="p">]</span><span class="o">=</span><span class="n">velocity</span>        
        
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>
        <span class="n">curser</span><span class="o">.</span><span class="n">set_specs_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">leading_silence</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curser</span><span class="o">.</span><span class="n">is_silence</span><span class="p">():</span>
            <span class="n">origin</span> <span class="o">+=</span> <span class="n">curser</span><span class="o">.</span><span class="n">interval2semitone</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span> <span class="p">[</span> <span class="n">leading_silence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">origin</span> <span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leading_silence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="n">curser</span><span class="o">.</span><span class="n">set_specs_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curser</span><span class="o">.</span><span class="n">is_silence</span><span class="p">():</span>   
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>       <span class="c1">#if they are different</span>
                    <span class="n">origin</span><span class="o">+=</span><span class="n">curser</span><span class="o">.</span><span class="n">interval2semitone</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">origin</span><span class="p">]</span><span class="o">=</span><span class="n">velocity</span>        
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span></div>
<div class="viewcode-block" id="embedder.intervals2pianoroll_melody"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.intervals2pianoroll_melody">[docs]</a>    <span class="k">def</span> <span class="nf">intervals2pianoroll_melody</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is depricated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Call to function:</span>
<span class="sd">            :func:`get_pianoroll_from_melodic_intervals`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pianoroll_from_melodic_intervals</span><span class="p">()</span></div>
        
          
<div class="viewcode-block" id="embedder.get_harmonic_intervals_from_pianoroll"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_harmonic_intervals_from_pianoroll">[docs]</a>    <span class="k">def</span> <span class="nf">get_harmonic_intervals_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_pianoroll</span><span class="p">,</span> <span class="n">pianoroll</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Creates sequence of harmonic intervals from pianoroll.</span>
<span class="sd">        </span>
<span class="sd">        Calculates the harmonic intervals of the highest pitch notes in self.pianoroll with respect to ref_pianoroll.        </span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.pianoroll`.</span>
<span class="sd">        - Updates `self.pianoroll` if pianoroll argument is passed.</span>
<span class="sd">        - Updates `self.intervals`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pianoroll : ndarray, dtype=uint8, shape=(?, 128), optional</span>
<span class="sd">            If None, the function expects self.pianoroll to have value; else, it overwrites self.pianoroll. First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>
<span class="sd">            </span>
<span class="sd">        ref_pianoroll : ndarray, dtype=uint8, shape=(?, 128)</span>
<span class="sd">            Harmonic intervals are calculated with reference to this pianoroll.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span>
<span class="sd">            First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pianoroll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">pianoroll</span>
            
        <span class="n">notes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_highest_pitch_notes_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">),</span><span class="n">interval</span><span class="o">.</span><span class="n">feature_dimensions</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>
        
        <span class="n">silent_interval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">get_silence_specs_list</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>                     <span class="c1">#it is silence</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span>   
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_note</span><span class="o">=</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="n">ref_note</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ref_pianoroll</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">ref_note</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ref_note</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">ref_note</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>                    
                    <span class="n">curser</span><span class="o">.</span><span class="n">semitones</span><span class="o">=</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ref_note</span>
                    <span class="n">curser</span><span class="o">.</span><span class="n">semitone2interval</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">curser</span><span class="o">.</span><span class="n">get_specs_list</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span> 
                
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span></div>
<div class="viewcode-block" id="embedder.pianoroll2intervals_harmony"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.pianoroll2intervals_harmony">[docs]</a>    <span class="k">def</span> <span class="nf">pianoroll2intervals_harmony</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is depricated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Call to function:</span>
<span class="sd">            :func:`get_harmonic_intervals_from_pianoroll`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_harmonic_intervals_from_pianoroll</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="embedder.get_pianoroll_from_harmonic_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_pianoroll_from_harmonic_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_pianoroll_from_harmonic_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pianoroll</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates pianoroll from sequence of harmonic intervals.</span>
<span class="sd">        </span>
<span class="sd">        Extracts highest pitch notes from self.pianoroll first, then builds a new pianoroll based on the extracted notes and self.intervals(harmonic).</span>
<span class="sd">        </span>
<span class="sd">        **Example:** Given ATB choir pianoroll and Soprano&#39;s harmonic intervals with respect to Alto, returns Soprano&#39;s pianoroll.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----        </span>
<span class="sd">        - Works on `self.intervals`.</span>
<span class="sd">        - Updates `self.intervals` if intervals argument is passed.</span>
<span class="sd">        - Updates `self.pianoroll`.        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pianoroll : ndarray, dtype=uint8, shape=(?, 128), optional</span>
<span class="sd">            If None, the function expects self.pianoroll to have value; else, it overwrites self.pianoroll. First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>
<span class="sd">            </span>
<span class="sd">        intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">            If None, the function expects self.intervals to have value; else, it overwrites self.intervals. First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">        </span>
<span class="sd">        velocity : int, optional</span>
<span class="sd">           When creating pianorolls this value is used for notes&#39; velocities. The default is self.default_velocity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=uint8, shape=(?, 128)</span>
<span class="sd">            First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pianoroll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">pianoroll</span>
            
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
            
        <span class="k">if</span> <span class="n">velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">velocity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_velocity</span>
            
        <span class="n">ref_notes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_highest_pitch_notes_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">),</span><span class="mi">128</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>   <span class="c1">#128 is the number of notes in MIDI</span>
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_notes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ref_notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>                               <span class="c1">#if it is not silence</span>
                <span class="n">curser</span><span class="o">.</span><span class="n">set_specs_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">note</span><span class="o">=</span><span class="n">curser</span><span class="o">.</span><span class="n">interval2semitone</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ref_notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">note</span><span class="p">]</span><span class="o">=</span><span class="n">velocity</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span></div>
<div class="viewcode-block" id="embedder.intervals2pianoroll_harmony"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.intervals2pianoroll_harmony">[docs]</a>    <span class="k">def</span> <span class="nf">intervals2pianoroll_harmony</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is depricated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Call to function:</span>
<span class="sd">            :func:`get_pianoroll_from_harmonic_intervals`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pianoroll_from_harmonic_intervals</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="embedder.get_barwise_intervals_from_pianoroll"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_barwise_intervals_from_pianoroll">[docs]</a>    <span class="k">def</span> <span class="nf">get_barwise_intervals_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pianoroll</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_per_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates sequence of barwise intervals from pianoroll.</span>
<span class="sd">        </span>
<span class="sd">        Calculates intervals with respect to the first note of the current bar. For first notes of bars, the interval is calculated with respect to the first note of the last bar.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on highest pitch notes in `self.pianoroll`.</span>
<span class="sd">        - Updates `self.pianoroll` if pianoroll argument is passed.</span>
<span class="sd">        - Updates `self.intervals`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pianoroll : ndarray, dtype=uint8, shape=(?, 128), optional</span>
<span class="sd">            If None, the function expects self.pianoroll to have value; else, it overwrites self.pianoroll. First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>
<span class="sd">        </span>
<span class="sd">        pixels_per_bar: int, optional</span>
<span class="sd">            Number of pixels in each bar. Equals time signature&#39;s numarator multiplied by resolution per pixel. The default is self.pixels_per_bar.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span>
<span class="sd">            First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="k">if</span> <span class="n">pianoroll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">pianoroll</span>
        
        <span class="k">if</span> <span class="n">pixels_per_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pixels_per_bar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels_per_bar</span>
            
        <span class="n">notes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_highest_pitch_notes_from_pianoroll</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1">#get the notes of the melody</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">),</span><span class="n">interval</span><span class="o">.</span><span class="n">feature_dimensions</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="c1">#create the placeholder of intervals. </span>
                
        <span class="n">last_bar_ref_note</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>      <span class="c1">#init with an impossible value</span>
        <span class="k">for</span> <span class="n">note</span> <span class="ow">in</span> <span class="n">notes</span><span class="p">:</span>          <span class="c1">#find first note</span>
            <span class="k">if</span> <span class="n">note</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">last_bar_ref_note</span> <span class="o">=</span> <span class="n">note</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">last_bar_ref_note</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1">#this means all notes are 0; there is nothing to process</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span>
                
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>
        <span class="n">silent_interval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">get_silence_specs_list</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">bar_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">)</span><span class="o">/</span><span class="n">pixels_per_bar</span><span class="p">)):</span>        <span class="c1">#traversing bars</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">notes</span><span class="p">[</span><span class="n">bar_number</span> <span class="o">*</span> <span class="n">pixels_per_bar</span> <span class="p">:</span> <span class="p">(</span><span class="n">bar_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixels_per_bar</span> <span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="c1">#bar is empty</span>
                <span class="k">continue</span>
            
            <span class="n">i</span><span class="o">=</span><span class="n">bar_number</span><span class="o">*</span><span class="n">pixels_per_bar</span>                                   <span class="c1">#init counter i with the first pixel of the bar</span>
            <span class="k">while</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">bar_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixels_per_bar</span> <span class="ow">and</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    <span class="c1">#finding the first note of the bar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span> 
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">notes</span><span class="p">):</span>                                        <span class="c1">#this ensures i does not exceed array boundaries which might happen at the last pixel of the last bar.</span>
                <span class="n">ref_note</span> <span class="o">=</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="n">curser</span><span class="o">.</span><span class="n">semitones</span><span class="o">=</span><span class="n">ref_note</span><span class="o">-</span><span class="n">last_bar_ref_note</span>         <span class="c1">#finding the interval of the first note of the current bar with respect to the first note of the last bar</span>
            <span class="n">curser</span><span class="o">.</span><span class="n">semitone2interval</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">curser</span><span class="o">.</span><span class="n">get_specs_list</span><span class="p">()</span>
            <span class="n">last_bar_ref_note</span><span class="o">=</span><span class="n">ref_note</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">bar_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixels_per_bar</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">silent_interval</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curser</span><span class="o">.</span><span class="n">semitones</span><span class="o">=</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ref_note</span>
                    <span class="n">curser</span><span class="o">.</span><span class="n">semitone2interval</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">curser</span><span class="o">.</span><span class="n">get_specs_list</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span></div>
    

<div class="viewcode-block" id="embedder.get_pianoroll_from_barwise_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_pianoroll_from_barwise_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_pianoroll_from_barwise_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leading_silence</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pixels_per_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates pianoroll from sequence of barwise intervals.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.intervals`.</span>
<span class="sd">        - Updates `self.intervals` if intervals argument is passed.</span>
<span class="sd">        - Updates `self.pianoroll`.        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">            If None, the function expects self.intervals to have value; else, it overwrites self.intervals. First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">            </span>
<span class="sd">        origin: int, optional</span>
<span class="sd">            The reference note of the melody; when decoding the melody, this indicates the first note. The default is self.origin.</span>
<span class="sd">            </span>
<span class="sd">        velocity : int, optional</span>
<span class="sd">           When creating pianorolls this value is used for notes&#39; velocities. The default is self.default_velocity.</span>
<span class="sd">            </span>
<span class="sd">        leading_silence: int, optional</span>
<span class="sd">            Number of silent pixels at the beginning of the melody.</span>
<span class="sd">            </span>
<span class="sd">        pixels_per_bar: int, optional</span>
<span class="sd">            Number of pixels in each bar. Equals time signature&#39;s numarator multiplied by resolution per pixel. The default is self.pixels_per_bar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=uint8, shape=(?, 128)</span>
<span class="sd">            First dimension is timesteps and second dimension is fixed 128 per MIDI standard.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
        
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
            
        <span class="k">if</span> <span class="n">velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">velocity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_velocity</span>
            
        <span class="k">if</span> <span class="n">pixels_per_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pixels_per_bar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels_per_bar</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">),</span><span class="mi">128</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>   <span class="c1">#128 is the number of notes in MIDI        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span> <span class="p">[</span> <span class="n">leading_silence</span><span class="p">,</span> <span class="n">origin</span><span class="p">]</span><span class="o">=</span><span class="n">velocity</span>
       
        <span class="n">curser</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>            
        <span class="n">last_known_origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="n">origin_is_unkown</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leading_silence</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">pixels_per_bar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>         <span class="c1">#a new bar has started, we need to find its first note</span>
                <span class="n">origin_is_unkown</span> <span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">if</span> <span class="n">origin_is_unkown</span><span class="p">:</span> 
                <span class="n">curser</span><span class="o">.</span><span class="n">set_specs_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>                    <span class="c1">#this is the interval of the first note of the current bar with respect to the first note of the last bar</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">curser</span><span class="o">.</span><span class="n">is_silence</span><span class="p">():</span>       <span class="c1">#skip silences</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="n">last_known_origin</span> <span class="o">+</span> <span class="n">curser</span><span class="o">.</span><span class="n">interval2semitone</span><span class="p">()</span>     <span class="c1">#finding the first note of the current bar</span>
                    <span class="n">last_known_origin</span> <span class="o">=</span> <span class="n">origin</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span> <span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">origin</span> <span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>
                    <span class="n">origin_is_unkown</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">curser</span><span class="o">.</span><span class="n">set_specs_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">curser</span><span class="o">.</span><span class="n">is_silence</span><span class="p">():</span>      <span class="c1">#skip silences                    </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span> <span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">origin</span> <span class="o">+</span> <span class="n">curser</span><span class="o">.</span><span class="n">interval2semitone</span><span class="p">()</span> <span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pianoroll</span></div>
    
<div class="viewcode-block" id="embedder.chunk_sequence_of_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.chunk_sequence_of_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">chunk_sequence_of_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_per_chunk</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Breaks a long sequence of intervals into chunks.        </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.intervals`.</span>
<span class="sd">        - Updates `self.intervals` if intervals argument is passed. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">            If None, the function expects self.intervals to have value; else, it overwrites self.intervals. First dimension is timesteps and second dimension is interval features.</span>
<span class="sd">            </span>
<span class="sd">        pixels_per_chunk: int, optional</span>
<span class="sd">            Number of pixels in each chunk. Set it to time signature&#39;s numarator multiplied by resolution per pixel to get chunk_per-bar. The default is self.pixels_per_bar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, pixels_per_chunk, interval.feature_dimensions)</span>
<span class="sd">            First dimension is bars, second dimension is pixels in each chunk and, third dimension is interval features.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
            
        <span class="k">if</span> <span class="n">pixels_per_chunk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pixels_per_chunk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels_per_bar</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="n">pixels_per_chunk</span> <span class="p">,</span> <span class="n">pixels_per_chunk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">))</span></div>
    
    
<div class="viewcode-block" id="embedder.merge_chunked_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.merge_chunked_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">merge_chunked_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunked_intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges chunks of interval sequence.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Updates `self.intervals`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunked_intervals : ndarray, dtype=int8, shape=(?, ?, interval.feature_dimensions)</span>
<span class="sd">            Merging happens along the first dimension and removes the second dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span>
<span class="sd">            First dimension is timesteps and second dimension is interval features.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chunked_intervals</span><span class="p">,</span> <span class="p">(</span> <span class="n">chunked_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">chunked_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">chunked_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span></div>

<div class="viewcode-block" id="embedder.get_RLE_from_intervals"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_RLE_from_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">get_RLE_from_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compresses sequence of intervals using Run-Length Encoding.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Works on `self.intervals`.</span>
<span class="sd">        - Updates `self.intervals` if `intervals` argument is passed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intervals : ndarray, dtype=int8, shape=(?, interval.feature_dimensions), optional</span>
<span class="sd">            If None, the function expects self.intervals to have value; else, it overwrites self.intervals. First dimension is timesteps and second dimension is interval features.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int32, shape=(?, interval.feature_dimensions + 1)</span>
<span class="sd">            First dimension is compressed timesteps. The last element in the second dimension indicates number of repeatitions for the rest of the elements in the second dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span>
        
        <span class="n">RLE</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="n">RLE</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">RLE</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">RLE</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">RLE</span><span class="p">[</span><span class="n">index</span><span class="p">,:</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">RLE</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                
        <span class="k">return</span> <span class="n">RLE</span><span class="p">[:</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,:]</span></div>
    
<div class="viewcode-block" id="embedder.get_intervals_from_RLE"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_intervals_from_RLE">[docs]</a>    <span class="k">def</span> <span class="nf">get_intervals_from_RLE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RLE_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uncompresses Run-Length Encoded intervals data.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Updates `self.intervals`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        RLE_data : ndarray, dtype=int32, shape=(?, interval.feature_dimensions + 1)</span>
<span class="sd">            First dimension is compressed timesteps. The last element in the second dimension indicates number of repeatitions for the rest of the elements in the second dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, interval.feature_dimensions)</span>
<span class="sd">            First dimension is timesteps and second dimension is interval features.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">RLE_data</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span> <span class="p">)</span>
        <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">RLE_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">replacement</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">repeats</span><span class="o">=</span><span class="n">RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>            
            <span class="n">replacement</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">replacement</span><span class="p">,(</span><span class="n">RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="n">RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">replacement</span>
            <span class="n">index</span><span class="o">+=</span><span class="n">RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span></div>
    
<div class="viewcode-block" id="embedder.get_RLE_from_intervals_bulk"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_RLE_from_intervals_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">get_RLE_from_intervals_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulk_intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bulk version of :func:`get_RLE_from_intervals`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bulk_intervals : ndarray, dtype=int8, shape=(?, pixels_per_chunk, interval.feature_dimensions)</span>
<span class="sd">            First dimension is chunks, second dimension is pixels in each chunk and, third dimension is interval features.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of RLE_compressed data, see :func:`get_intervals_from_RLE`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">RLE_bulk</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">intervals</span> <span class="ow">in</span> <span class="n">bulk_intervals</span><span class="p">:</span>
            <span class="n">RLE_bulk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_RLE_from_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">))</span>        
                
        <span class="k">return</span> <span class="n">RLE_bulk</span></div>
    
<div class="viewcode-block" id="embedder.get_intervals_from_RLE_bulk"><a class="viewcode-back" href="../../embedder.html#music_embedding.embedder.embedder.get_intervals_from_RLE_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">get_intervals_from_RLE_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulk_RLE_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bulk version of :func:`get_intervals_from_RLE`.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Infers output size from the first chunk.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bulk_RLE_data : list</span>
<span class="sd">            List of RLE_compressed data, see self.get_intervals_from_RLE.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, dtype=int8, shape=(?, pixels_per_chunk, interval.feature_dimensions)</span>
<span class="sd">            First dimension is chunks, second dimension is pixels in each chunk and, third dimension is interval features.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_intervals_from_RLE</span><span class="p">(</span><span class="n">bulk_RLE_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        <span class="c1">#just to identify the shape</span>
        <span class="n">bulk_intervals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk_RLE_data</span><span class="p">),</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk_RLE_data</span><span class="p">)):</span>
            <span class="n">bulk_intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_intervals_from_RLE</span><span class="p">(</span><span class="n">bulk_RLE_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">bulk_intervals</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Music Embedding</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../embedder.html">Embedder</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, SeyyedPooya HekmatiAthar.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>